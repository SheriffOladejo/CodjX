"use strict";
/* eslint-disable no-unused-vars */
Object.defineProperty(exports, "__esModule", { value: true });
const bigint_1 = require("./polyfills/bigint");
const dataview_1 = require("./polyfills/dataview");
const buffer_1 = require("./polyfills/buffer");
// Import our default bindings depending on the environment
let defaultBindings;
/*ROLLUP_REPLACE_NODE
import nodeBindings from "./bindings/node";
defaultBindings = nodeBindings;
ROLLUP_REPLACE_NODE*/
/*ROLLUP_REPLACE_BROWSER
import browserBindings from "./bindings/browser";
browserBindings = require("./bindings/browser");
defaultBindings = browserBindings;
ROLLUP_REPLACE_BROWSER*/
/*

This project is based from the Node implementation made by Gus Caplan
https://github.com/devsnek/node-wasi
However, JavaScript WASI is focused on:
 * Bringing WASI to the Browsers
 * Make easy to plug different filesystems
 * Provide a type-safe api using Typescript
 * Providing multiple output targets to support both browsers and node
 * The API is adapted to the Node-WASI API: https://github.com/nodejs/wasi/blob/wasi/lib/wasi.js

Copyright 2019 Gus Caplan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

 */
const constants_1 = require("./constants");
const STDIN_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC |
    constants_1.WASI_RIGHT_FD_READ |
    constants_1.WASI_RIGHT_FD_SYNC |
    constants_1.WASI_RIGHT_FD_ADVISE |
    constants_1.WASI_RIGHT_FD_FILESTAT_GET |
    constants_1.WASI_RIGHT_POLL_FD_READWRITE;
const STDOUT_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC |
    constants_1.WASI_RIGHT_FD_WRITE |
    constants_1.WASI_RIGHT_FD_SYNC |
    constants_1.WASI_RIGHT_FD_ADVISE |
    constants_1.WASI_RIGHT_FD_FILESTAT_GET |
    constants_1.WASI_RIGHT_POLL_FD_READWRITE;
const STDERR_DEFAULT_RIGHTS = STDOUT_DEFAULT_RIGHTS;
const msToNs = (ms) => {
	// ms is for micro-seconds, not milli-seconds
    const msInt = Math.trunc(ms);
    const decimal = bigint_1.BigIntPolyfill(Math.round((ms - msInt) * 1000));
    const ns = bigint_1.BigIntPolyfill(msInt) * bigint_1.BigIntPolyfill(1000n);
    return BigInt(ns + decimal);
};
// iOS: get stats from libc:
const parseStats = (array) => {
	var result = {};
	result.rdev = 0; 
	result.blksize = 4096; 
	result.dev = 0; 
	var length = array.length;
	for (var i = 0; i < length; i++) {
		var entry = array[i];
		if (entry.startsWith("st_mode:")) {
			result.mode = Number(entry.split(":").pop());
		} else if (entry.startsWith("st_uid")) {
			result.uid = Number(entry.split(":").pop());
		} else if (entry.startsWith("st_gid")) {
			result.gid = Number(entry.split(":").pop());
		} else if (entry.startsWith("st_size")) {
			result.size = Number(entry.split(":").pop());
		} else if (entry.startsWith("st_blocks")) {
			result.blocks = Number(entry.split(":").pop());
		} else if (entry.startsWith("st_ino")) {
			result.ino = Number(entry.split(":").pop());
		} else if (entry.startsWith("st_nlink")) {
			result.nlink = Number(entry.split(":").pop());
		} else if (entry.startsWith("st_atimespec")) {
			let seconds = BigInt(entry.split(":").pop());
			let nanoseconds = BigInt(array[i+1].substr(0, array[i+1].length - 1).split(":").pop());
			result.atimeMs = Number(seconds * 1000000n + (nanoseconds / 1000n)); 
			result.atime = new Date(result.atimeMs/1000); 
		} else if (entry.startsWith("st_ctimespec")) {
			let seconds = BigInt(entry.split(":").pop());
			let nanoseconds = BigInt(array[i+1].substr(0, array[i+1].length - 1).split(":").pop());
			result.ctimeMs = Number(seconds * 1000000n + (nanoseconds / 1000n)); 
			result.ctime = new Date(result.ctimeMs/1000); 
			result.birthtime = result.ctime;
			result.birthtimeMs = result.ctimeMs;
		} else if (entry.startsWith("st_mtimespec")) {
			let seconds = BigInt(entry.split(":").pop());
			let nanoseconds = BigInt(array[i+1].substr(0, array[i+1].length - 1).split(":").pop());
			result.mtimeMs = Number(seconds * 1000000n + (nanoseconds / 1000n));
			result.mtime = new Date(result.mtimeMs/1000); 
		}
	}
	return result;
}
const fs_statSync = (path) => {
	let statsFromC = prompt("libc\nstat\n" + path);
	if (!statsFromC.startsWith("stat(")) {
		// error. Let's throw:
		throwLibCError(-Number(statsFromC));
	}
	var statsSplit = statsFromC.substr(5, statsFromC.length - 6).split(", ");
	return parseStats(statsSplit);
}
const fs_fstatSync = (fd) => {
	let statsFromC = prompt("libc\nfstat\n" + fd);
	if (!statsFromC.startsWith("stat(")) {
		// error. Let's throw:
		throwLibCError(-Number(statsFromC));
	}
	var statsSplit = statsFromC.substr(5, statsFromC.length - 6).split(", ");
	return parseStats(statsSplit);
}
const throwLibCError = (errno) => {
	// Convert error codes from BSD into WASI_ErrorCodes
	// (and no, it is not a simple 1-for-1 map)
	switch (errno) {
		case 1: 
			throw new WASIError(constants_1.WASI_EPERM);
		case 2: 
			throw new WASIError(constants_1.WASI_ENOENT);
		case 3: 
			throw new WASIError(constants_1.WASI_ESRCH);
		case 4: 
			throw new WASIError(constants_1.WASI_EINTR);
		case 5: 
			throw new WASIError(constants_1.WASI_EIO);
		case 6: 
			throw new WASIError(constants_1.WASI_ENXIO);
		case 7: 
			throw new WASIError(constants_1.WASI_E2BIG);
		case 8: 
			throw new WASIError(constants_1.WASI_ENOEXEC);
		case 9: 
			throw new WASIError(constants_1.WASI_EBADF);
		case 10: 
			throw new WASIError(constants_1.WASI_ECHILD);
		case 11: 
			throw new WASIError(constants_1.WASI_EDEADLK);
		case 12: 
			throw new WASIError(constants_1.WASI_ENOMEM);
		case 13: 
			throw new WASIError(constants_1.WASI_EACCES);
		case 14: 
			throw new WASIError(constants_1.WASI_EFAULT);
		// case 15: 
			// throw new WASIError(constants_1.WASI_ENOTBLK);
		case 16: 
			throw new WASIError(constants_1.WASI_EBUSY);
		case 17: 
			throw new WASIError(constants_1.WASI_EEXIST);
		case 18: 
			throw new WASIError(constants_1.WASI_EXDEV);
		case 19: 
			throw new WASIError(constants_1.WASI_ENODEV);
		case 20: 
			throw new WASIError(constants_1.WASI_ENOTDIR);
		case 21: 
			throw new WASIError(constants_1.WASI_EISDIR);
		case 22: 
			throw new WASIError(constants_1.WASI_EINVAL);
		case 23: 
			throw new WASIError(constants_1.WASI_ENFILE);
		case 24: 
			throw new WASIError(constants_1.WASI_EMFILE);
		case 25: 
			throw new WASIError(constants_1.WASI_ENOTTY);
	    case 48: 	
			throw new WASIError(constants_1.WASI_EADDRINUSE);
		case 49:
			throw new WASIError(constants_1.WASI_EADDRNOTAVAIL);
		case  47: 
			throw new WASIError(constants_1.WASI_EAFNOSUPPORT);
		case 35: 
			throw new WASIError(constants_1.WASI_EAGAIN);
		case 37: 
			throw new WASIError(constants_1.WASI_EALREADY);
		case 94: 
			throw new WASIError(constants_1.WASI_EBADMSG);
		case 89: 
			throw new WASIError(constants_1.WASI_ECANCELED);
		case 53: 
			throw new WASIError(constants_1.WASI_ECONNABORTED);
		case 61: 
			throw new WASIError(constants_1.WASI_ECONNREFUSED);
		case 54: 
			throw new WASIError(constants_1.WASI_ECONNRESET);
		case 39: 
			throw new WASIError(constants_1.WASI_EDESTADDRREQ);
		case 33: 
			throw new WASIError(constants_1.WASI_EDOM);
		case 69: 
			throw new WASIError(constants_1.WASI_EDQUOT);
		case 27: 
			throw new WASIError(constants_1.WASI_EFBIG);
		case 65: 
			throw new WASIError(constants_1.WASI_EHOSTUNREACH);
		case 90: 
			throw new WASIError(constants_1.WASI_EIDRM);
		case 92: 
			throw new WASIError(constants_1.WASI_EILSEQ);
		case 36: 
			throw new WASIError(constants_1.WASI_EINPROGRESS);
		case 56: 
			throw new WASIError(constants_1.WASI_EISCONN);
		case 62: 
			throw new WASIError(constants_1.WASI_ELOOP);
		case 31: 
			throw new WASIError(constants_1.WASI_EMLINK);
		case 40: 
			throw new WASIError(constants_1.WASI_EMSGSIZE);
		case 95: 
			throw new WASIError(constants_1.WASI_EMULTIHOP);
		case 63: 
			throw new WASIError(constants_1.WASI_ENAMETOOLONG);
		case 50: 
			throw new WASIError(constants_1.WASI_ENETDOWN);
		case 52: 
			throw new WASIError(constants_1.WASI_ENETRESET);
		case 51: 
			throw new WASIError(constants_1.WASI_ENETUNREACH);
		case 55: 
			throw new WASIError(constants_1.WASI_ENOBUFS);
		case 77: 	
			throw new WASIError(constants_1.WASI_ENOLCK);
		case 97: 
			throw new WASIError(constants_1.WASI_ENOLINK);
		case 91: 
			throw new WASIError(constants_1.WASI_ENOMSG);
		case 42:
			throw new WASIError(constants_1.WASI_ENOPROTOOPT);
		case 28: 
			throw new WASIError(constants_1.WASI_ENOSPC);
		case 78: 
			throw new WASIError(constants_1.WASI_ENOSYS);
		case 57:
			throw new WASIError(constants_1.WASI_ENOTCONN);
		case 66: 
			throw new WASIError(constants_1.WASI_ENOTEMPTY);
		case 38:
			throw new WASIError(constants_1.WASI_ENOTSOCK);
		case 45:
			throw new WASIError(constants_1.WASI_ENOTSUP);
		case 84: 
			throw new WASIError(constants_1.WASI_EOVERFLOW);
		case 32: 
			throw new WASIError(constants_1.WASI_EPIPE);
		case 100: 
			throw new WASIError(constants_1.WASI_EPROTO);
		case 43: 
			throw new WASIError(constants_1.WASI_EPROTONOSUPPORT);
		case 41: 
			throw new WASIError(constants_1.WASI_EPROTOTYPE);
		case 34: 
			throw new WASIError(constants_1.WASI_ERANGE);
		case 30: 
			throw new WASIError(constants_1.WASI_EROFS);
		case 29: 
			throw new WASIError(constants_1.WASI_ESPIPE);
		case 70: 
			throw new WASIError(constants_1.WASI_ESTALE);
		case 60: 
			throw new WASIError(constants_1.WASI_ETIMEDOUT);
		case 26: 
			throw new WASIError(constants_1.WASI_ETXTBSY);
	// No known equivalents in Posix: 
	// throw new WASIError(constants_1.WASI_ENOTCAPABLE);
	// throw new WASIError(constants_1.WASI_ENOTRECOVERABLE);
	// throw new WASIError(constants_1.WASI_EOWNERDEAD);
	}
	// Unknown error code. Throw anyway: 
    throw new WASIError(constants_1.WASI_EPERM);
}
const wrap = (f) => (...args) => {
    try {
        return f(...args);
    }
    catch (e) {
        // If it's an error from the fs
        if (e && e.code && typeof e.code === "string") {
            return constants_1.ERROR_MAP[e.code] || constants_1.WASI_EINVAL;
        }
        // If it's a WASI error, we return it directly
        if (e instanceof WASIError) {
            return e.errno;
        }
        // Otherwise we let the error bubble up
        throw e;
    }
};
// iOS: reads parameters stored in wasi.FD_MAP. Mainly rights and path.
// fstatSync also reading from a stored database.
// Entire file system (wasmfs) not designed to store actual rights.
const stat = (wasi, fd) => {
    const entry = wasi.FD_MAP.get(fd);
    if (!entry) {
        throw new WASIError(constants_1.WASI_EBADF);
    }
    if (entry.filetype === undefined) {
    	// iOS: get the stats from the device:
    	const stats = fs_fstatSync(entry.real); 
        const { filetype, rightsBase, rightsInheriting } = translateFileAttributesFromMode(wasi, fd, stats.mode);
        // not iOS: get info from wasmfs:
        // const stats = wasi.bindings.fs.fstatSync(entry.real);
        // const { filetype, rightsBase, rightsInheriting } = translateFileAttributes(wasi, fd, stats);
        entry.filetype = filetype;
        if (!entry.rights) {
            entry.rights = {
                base: rightsBase,
                inheriting: rightsInheriting
            };
        }
    }
    return entry;
};
const translateFileAttributesFromMode = (wasi, fd, mode) => {
    var S_IFMT= 61440,
    S_IFREG= 32768,
    S_IFDIR= 16384,
    S_IFCHR= 8192,
    S_IFBLK= 24576,
    S_IFIFO= 4096,
    S_IFLNK= 40960,
    S_IFSOCK= 49152;
	
    const _checkModeProperty = (property) => {
        return (Number(mode) & S_IFMT) === property;
    };
    const isDirectory = () => {
        return _checkModeProperty(S_IFDIR);
    };
    const isFile =() =>  {
        return _checkModeProperty(S_IFREG);
    };
    const isBlockDevice = () =>  {
        return _checkModeProperty(S_IFBLK);
    };
    const isCharacterDevice = () =>  {
        return _checkModeProperty(S_IFCHR);
    };
    const isSymbolicLink = () =>  {
        return _checkModeProperty(S_IFLNK);
    };
    const isFIFO = () =>  {
        return _checkModeProperty(S_IFIFO);
    };
    const isSocket = () =>  {
        return _checkModeProperty(S_IFSOCK);
    };
	
    switch (true) {
        case isBlockDevice():
            return {
                filetype: constants_1.WASI_FILETYPE_BLOCK_DEVICE,
                rightsBase: constants_1.RIGHTS_BLOCK_DEVICE_BASE,
                rightsInheriting: constants_1.RIGHTS_BLOCK_DEVICE_INHERITING
            };
        case isCharacterDevice(): {
            const filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;
            if (fd !== undefined && wasi.bindings.isTTY(fd)) {
                return {
                    filetype,
                    rightsBase: constants_1.RIGHTS_TTY_BASE,
                    rightsInheriting: constants_1.RIGHTS_TTY_INHERITING
                };
            }
            return {
                filetype,
                rightsBase: constants_1.RIGHTS_CHARACTER_DEVICE_BASE,
                rightsInheriting: constants_1.RIGHTS_CHARACTER_DEVICE_INHERITING
            };
        }
        case isDirectory():
            return {
                filetype: constants_1.WASI_FILETYPE_DIRECTORY,
                rightsBase: constants_1.RIGHTS_DIRECTORY_BASE,
                rightsInheriting: constants_1.RIGHTS_DIRECTORY_INHERITING
            };
        case isFIFO():
            return {
                filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,
                rightsBase: constants_1.RIGHTS_SOCKET_BASE,
                rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING
            };
        case isFile():
            return {
                filetype: constants_1.WASI_FILETYPE_REGULAR_FILE,
                rightsBase: constants_1.RIGHTS_REGULAR_FILE_BASE,
                rightsInheriting: constants_1.RIGHTS_REGULAR_FILE_INHERITING
            };
        case isSocket():
            return {
                filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,
                rightsBase: constants_1.RIGHTS_SOCKET_BASE,
                rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING
            };
        case isSymbolicLink():
            return {
                filetype: constants_1.WASI_FILETYPE_SYMBOLIC_LINK,
                rightsBase: bigint_1.BigIntPolyfill(0),
                rightsInheriting: bigint_1.BigIntPolyfill(0)
            };
        default:
            return {
                filetype: constants_1.WASI_FILETYPE_UNKNOWN,
                rightsBase: bigint_1.BigIntPolyfill(0),
                rightsInheriting: bigint_1.BigIntPolyfill(0)
            };
    }
};
const translateFileAttributes = (wasi, fd, stats) => {
    switch (true) {
        case stats.isBlockDevice():
            return {
                filetype: constants_1.WASI_FILETYPE_BLOCK_DEVICE,
                rightsBase: constants_1.RIGHTS_BLOCK_DEVICE_BASE,
                rightsInheriting: constants_1.RIGHTS_BLOCK_DEVICE_INHERITING
            };
        case stats.isCharacterDevice(): {
            const filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;
            if (fd !== undefined && wasi.bindings.isTTY(fd)) {
                return {
                    filetype,
                    rightsBase: constants_1.RIGHTS_TTY_BASE,
                    rightsInheriting: constants_1.RIGHTS_TTY_INHERITING
                };
            }
            return {
                filetype,
                rightsBase: constants_1.RIGHTS_CHARACTER_DEVICE_BASE,
                rightsInheriting: constants_1.RIGHTS_CHARACTER_DEVICE_INHERITING
            };
        }
        case stats.isDirectory():
            return {
                filetype: constants_1.WASI_FILETYPE_DIRECTORY,
                rightsBase: constants_1.RIGHTS_DIRECTORY_BASE,
                rightsInheriting: constants_1.RIGHTS_DIRECTORY_INHERITING
            };
        case stats.isFIFO():
            return {
                filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,
                rightsBase: constants_1.RIGHTS_SOCKET_BASE,
                rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING
            };
        case stats.isFile():
            return {
                filetype: constants_1.WASI_FILETYPE_REGULAR_FILE,
                rightsBase: constants_1.RIGHTS_REGULAR_FILE_BASE,
                rightsInheriting: constants_1.RIGHTS_REGULAR_FILE_INHERITING
            };
        case stats.isSocket():
            return {
                filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,
                rightsBase: constants_1.RIGHTS_SOCKET_BASE,
                rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING
            };
        case stats.isSymbolicLink():
            return {
                filetype: constants_1.WASI_FILETYPE_SYMBOLIC_LINK,
                rightsBase: bigint_1.BigIntPolyfill(0),
                rightsInheriting: bigint_1.BigIntPolyfill(0)
            };
        default:
            return {
                filetype: constants_1.WASI_FILETYPE_UNKNOWN,
                rightsBase: bigint_1.BigIntPolyfill(0),
                rightsInheriting: bigint_1.BigIntPolyfill(0)
            };
    }
};
class WASIError extends Error {
    constructor(errno) {
        super();
        this.errno = errno;
        Object.setPrototypeOf(this, WASIError.prototype);
    }
}
exports.WASIError = WASIError;
class WASIExitError extends Error {
    constructor(code) {
        super(`WASI Exit error: ${code}`);
        this.code = code;
        Object.setPrototypeOf(this, WASIExitError.prototype);
    }
}
exports.WASIExitError = WASIExitError;
class WASIKillError extends Error {
    constructor(signal) {
        super(`WASI Kill signal: ${signal}`);
        this.signal = signal;
        Object.setPrototypeOf(this, WASIKillError.prototype);
    }
}
// iOS: base64 decode:    
function b64ToUint6 (nChr) {

	return nChr > 64 && nChr < 91 ?
		nChr - 65
		: nChr > 96 && nChr < 123 ?
		nChr - 71
		: nChr > 47 && nChr < 58 ?
		nChr + 4
		: nChr === 43 ?
		62
		: nChr === 47 ?
		63
		:
		0;

}
function base64DecToArr (sBase64, nBlockSize) {
	var
	sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""), nInLen = sB64Enc.length,
		nOutLen = nBlockSize ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockSize) * nBlockSize : nInLen * 3 + 1 >>> 2, aBytes = new Uint8Array(nOutLen);

	for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
		nMod4 = nInIdx & 3;
		nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
		if (nMod4 === 3 || nInLen - nInIdx === 1) {
			for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
				aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
			}
			nUint24 = 0;
		}
	}
	return aBytes;
}
//
exports.WASIKillError = WASIKillError;
class WASIDefault {
    constructor(wasiConfig) {
        // Destructure our wasiConfig
        let preopens = {};
        if (wasiConfig && wasiConfig.preopens) {
            preopens = wasiConfig.preopens;
        }
        else if (wasiConfig && wasiConfig.preopenDirectories) {
            preopens = wasiConfig.preopenDirectories;
        }
        let env = {};
        if (wasiConfig && wasiConfig.env) {
            env = wasiConfig.env;
        }
        let args = [];
        if (wasiConfig && wasiConfig.args) {
            args = wasiConfig.args;
        }
        let bindings = defaultBindings;
        if (wasiConfig && wasiConfig.bindings) {
            bindings = wasiConfig.bindings;
        }
        // @ts-ignore
        this.memory = undefined;
        // @ts-ignore
        this.view = undefined;
        this.bindings = bindings;
        this.FD_MAP = new Map([
            [
                constants_1.WASI_STDIN_FILENO,
                {
                    real: 0,
                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,
                    // offset: BigInt(0),
                    rights: {
                        base: STDIN_DEFAULT_RIGHTS,
                        inheriting: bigint_1.BigIntPolyfill(0)
                    },
                    path: undefined
                }
            ],
            [
                constants_1.WASI_STDOUT_FILENO,
                {
                    real: 1,
                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,
                    // offset: BigInt(0),
                    rights: {
                        base: STDOUT_DEFAULT_RIGHTS,
                        inheriting: bigint_1.BigIntPolyfill(0)
                    },
                    path: undefined
                }
            ],
            [
                constants_1.WASI_STDERR_FILENO,
                {
                    real: 2,
                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,
                    // offset: BigInt(0),
                    rights: {
                        base: STDERR_DEFAULT_RIGHTS,
                        inheriting: bigint_1.BigIntPolyfill(0)
                    },
                    path: undefined
                }
            ]
        ]);
        let fs = this.bindings.fs;
        let path = this.bindings.path;
        for (const [k, v] of Object.entries(preopens)) {
            const newfd = [...this.FD_MAP.keys()].reverse()[0] + 1;
            const real = newfd; // iOS: was: fs.openSync(v, fs.constants.O_RDONLY);
            // iOS: real is not the real fd anymore, we'll set it up later.
            this.FD_MAP.set(newfd, {
                real,
                filetype: constants_1.WASI_FILETYPE_DIRECTORY,
                // offset: BigInt(0),
                rights: {
                    base: constants_1.RIGHTS_DIRECTORY_BASE,
                    inheriting: constants_1.RIGHTS_DIRECTORY_INHERITING
                },
                fakePath: k,
                path: v
            });
        }
        const getiovs = (iovs, iovsLen) => {
            // iovs* -> [iov, iov, ...]
            // __wasi_ciovec_t {
            //   void* buf,
            //   size_t buf_len,
            // }
            this.refreshMemory();
            const buffers = Array.from({ length: iovsLen }, (_, i) => {
                const ptr = iovs + i * 8;
                const buf = this.view.getUint32(ptr, true);
                const bufLen = this.view.getUint32(ptr + 4, true);
                return new Uint8Array(this.memory.buffer, buf, bufLen);
            });
            return buffers;
        };
        const CHECK_FD = (fd, rights) => {
            const stats = stat(this, fd);
            // console.log(`CHECK_FD: stats.real: ${stats.real}, stats.path:`, stats.path);
            if (rights !== bigint_1.BigIntPolyfill(0) && (stats.rights.base & rights) === bigint_1.BigIntPolyfill(0)) {
                throw new WASIError(constants_1.WASI_EPERM);
            }
            return stats;
        };
        const CPUTIME_START = bindings.hrtime();
        const now = (clockId) => {
            switch (clockId) {
                case constants_1.WASI_CLOCK_MONOTONIC:
                case constants_1.WASI_CLOCK_REALTIME:
                    return bindings.hrtime();
                case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:
                case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID:
                    // return bindings.hrtime(CPUTIME_START)
                    return bindings.hrtime() - CPUTIME_START;
                default:
                    return null;
            }
        };
        this.wasiImport = {
            args_get: (argv, argvBuf) => {
                this.refreshMemory();
                let coffset = argv;
                let offset = argvBuf;
                args.forEach(a => {
                    this.view.setUint32(coffset, offset, true);
                    coffset += 4;
                    offset += buffer_1.default.from(this.memory.buffer).write(`${a}\0`, offset);
                });
                return constants_1.WASI_ESUCCESS;
            },
            args_sizes_get: (argc, argvBufSize) => {
                this.refreshMemory();
                this.view.setUint32(argc, args.length, true);
                const size = args.reduce((acc, a) => acc + buffer_1.default.byteLength(a) + 1, 0);
                this.view.setUint32(argvBufSize, size, true);
                return constants_1.WASI_ESUCCESS;
            },
            environ_get: (environ, environBuf) => {
                this.refreshMemory();
                let coffset = environ;
                let offset = environBuf;
                Object.entries(env).forEach(([key, value]) => {
                    this.view.setUint32(coffset, offset, true);
                    coffset += 4;
                    offset += buffer_1.default.from(this.memory.buffer).write(`${key}=${value}\0`, offset);
                });
                return constants_1.WASI_ESUCCESS;
            },
            environ_sizes_get: (environCount, environBufSize) => {
                this.refreshMemory();
                const envProcessed = Object.entries(env).map(([key, value]) => `${key}=${value}\0`);
                const size = envProcessed.reduce((acc, e) => acc + buffer_1.default.byteLength(e), 0);
                this.view.setUint32(environCount, envProcessed.length, true);
                this.view.setUint32(environBufSize, size, true);
                return constants_1.WASI_ESUCCESS;
            },
            clock_res_get: (clockId, resolution) => {
                // this.view.setBigUint64(resolution, BigInt(0));
                return constants_1.WASI_ESUCCESS;
            },
            clock_time_get: (clockId, precision, time) => {
                this.refreshMemory();
                const n = now(clockId);
                if (n === null) {
                    return constants_1.WASI_EINVAL;
                }
                this.view.setBigUint64(time, bigint_1.BigIntPolyfill(n), true);
                return constants_1.WASI_ESUCCESS;
            },
            fd_advise: wrap((fd, offset, len, advice) => {
                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ADVISE);
                return constants_1.WASI_ENOSYS;
            }),
            fd_allocate: wrap((fd, offset, len) => {
                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ALLOCATE);
                return constants_1.WASI_ENOSYS;
            }),
            fd_close: wrap((fd) => {
                const stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));
                // fs.closeSync(stats.real);
                const returnValue = prompt("libc\nclose\n" + stats.real);
                this.FD_MAP.delete(fd);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_datasync: (fd) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_DATASYNC);
                // fs.fdatasyncSync(stats.real);
                // return constants_1.WASI_ESUCCESS;
                // fsync is the best replacement for fdatasync on BSD systems:
                let returnValue = prompt("libc\nfsync\n" + stats.real);
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}                
            },
            fd_fdstat_get: wrap((fd, bufPtr) => {
                const stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));
                this.refreshMemory();
                this.view.setUint8(bufPtr, stats.filetype); // FILETYPE u8
                this.view.setUint16(bufPtr + 2, 0, true); // FDFLAG u16
                this.view.setBigUint64(bufPtr + 8, bigint_1.BigIntPolyfill(stats.rights.base), true); // u64
                this.view.setBigUint64(bufPtr + 8 + 8, bigint_1.BigIntPolyfill(stats.rights.inheriting), true); // u64
                return constants_1.WASI_ESUCCESS;
            }),
            fd_fdstat_set_flags: wrap((fd, flags) => {
                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS);
                return constants_1.WASI_ENOSYS;
            }),
            fd_fdstat_set_rights: wrap((fd, fsRightsBase, fsRightsInheriting) => {
                const stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));
                const nrb = stats.rights.base | fsRightsBase;
                if (nrb > stats.rights.base) {
                    return constants_1.WASI_EPERM;
                }
                const nri = stats.rights.inheriting | fsRightsInheriting;
                if (nri > stats.rights.inheriting) {
                    return constants_1.WASI_EPERM;
                }
                stats.rights.base = nrb;
                stats.rights.inheriting = nri;
                return constants_1.WASI_ESUCCESS;
            }),
            fd_filestat_get: wrap((fd, bufPtr) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_GET);
                // iOS:
                // const rstats = fs.fstatSync(stats.real);
                const rstats = fs_fstatSync(stats.real);
                this.refreshMemory();
                this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.dev), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.ino), true);
                bufPtr += 8;
                this.view.setUint8(bufPtr, stats.filetype);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.nlink), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.size), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_filestat_set_size: wrap((fd, stSize) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE);
                // iOS: 
                // fs.ftruncate(stats.real, Number(stSize));
                // return constants_1.WASI_ESUCCESS;
                let returnValue = prompt("libc\nftruncate\n" + stats.real + "\n" + Number(stSize));
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
            }),
            fd_filestat_set_times: wrap((fd, stAtim, stAtim_ns, stMtim, stMtim_ns, fstflags) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_TIMES);
                const n = now(constants_1.WASI_CLOCK_REALTIME);
                const n_seconds = Math.trunc(n / 1000000000);
                const n_nano = n - 1000000000 * n_seconds;
                const atimNow = (fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) ===
                    constants_1.WASI_FILESTAT_SET_ATIM_NOW;
                const mtimNow = (fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) ===
                    constants_1.WASI_FILESTAT_SET_MTIM_NOW;
                // iOS:
                // fs.futimesSync(stats.real, atimNow ? n : stAtim, mtimNow ? n : stMtim);
                // return constants_1.WASI_ESUCCESS;
                let returnValue = prompt("libc\nfutimes\n" + stats.real + "\n" + 
                	Number(atimNow ? n_seconds : stAtim) + "\n" + 
                	Number(atimNow ? n_nano : stAtim_ns) + "\n" + 
                	Number(mtimNow ? n_seconds : stMtim) + "\n" + 
                	Number(mtimNow ? n_nano : stMtim_ns));
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
                
            }),
            fd_prestat_get: wrap((fd, bufPtr) => {
                const stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));
                if (!stats.path) {
                    return constants_1.WASI_EINVAL;
                }
                this.refreshMemory();
                this.view.setUint8(bufPtr, constants_1.WASI_PREOPENTYPE_DIR);
                this.view.setUint32(bufPtr + 4, buffer_1.default.byteLength(stats.fakePath), true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_prestat_dir_name: wrap((fd, pathPtr, pathLen) => {
                const stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));
                if (!stats.path) {
                    return constants_1.WASI_EINVAL;
                }
                this.refreshMemory();
                buffer_1.default.from(this.memory.buffer).write(stats.fakePath, pathPtr, pathLen, "utf8");
                return constants_1.WASI_ESUCCESS;
            }),
            fd_pwrite: wrap((fd, iovs, iovsLen, offset, nwritten) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SEEK);
                let written = 0;
                getiovs(iovs, iovsLen).forEach(iov => {
                    let w = 0;
                    // iOS: 
					w = Number(prompt("libc\nwrite\n" + stats.real + "\n" + iov + "\n" + iov.byteLength + "\n" + offset));
                    // while (w < iov.byteLength) {
                    //    w += fs.writeSync(stats.real, iov, w, iov.byteLength - w, offset + written + w);
                    // }
                    if (w < 0) {
						throwLibCError(-w)
					}
                    written += w;
                });
                this.view.setUint32(nwritten, written, true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_write: wrap((fd, iovs, iovsLen, nwritten) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE);
                let written = 0;
                getiovs(iovs, iovsLen).forEach(iov => {
					let offset = stats.offset ? Number(stats.offset) : 0
					let w = Number(prompt("libc\nwrite\n" + stats.real + "\n" + iov + "\n" + iov.byteLength + "\n" + offset));
                    if (w < 0) {
						throwLibCError(-w)
					}
                    written += w;
					if (stats.offset)
						stats.offset += bigint_1.BigIntPolyfill(w);
                    /* let w = 0;
                    while (w < iov.byteLength) {
                        const i = fs.writeSync(stats.real, iov, w, iov.byteLength - w, stats.offset ? Number(stats.offset) : null);
                        if (stats.offset)
                            stats.offset += bigint_1.BigIntPolyfill(i);
                        w += i;
                    } 
                    written += w; */ 
                });
                this.view.setUint32(nwritten, written, true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_pread: wrap((fd, iovs, iovsLen, offset, nread) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SEEK);
                let read = 0;
                getiovs(iovs, iovsLen).forEach(iov => {
                    let r = 0;
                    var tty = 0;
                    if (this.bindings.isTTY(fd)) {
                    	tty = 1;
					}
					let iov_base64 = prompt("libc\nread\n" +
						stats.real + "\n" + // fd
						iov.byteLength + "\n" + // length
						offset + "\n" + // position
						tty
					);
					let iov_array = base64DecToArr(iov_base64);
					r = iov_array.length;
					for (var i = 0; i < r; i++) {
						iov[i] = iov_array[i];
					}
                    // while (r < iov.byteLength) {
                    //     r += fs.readSync(stats.real, iov, r, iov.byteLength - r, offset + read + r);
                    // }
                    read += r;
                });
                this.view.setUint32(nread, read, true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_read: wrap((fd, iovs, iovsLen, nread) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ);
                const IS_STDIN = stats.real === 0;
                // iOS: check if stdin is a TTY. If so, avoid round trip.
                let read = 0;
                if (IS_STDIN && this.bindings.isTTY(fd)) {
					outer_stdin: for (const iov of getiovs(iovs, iovsLen)) {
						let r = 0;
						while (r < iov.byteLength) {
							let length = iov.byteLength - r;
							let position = null; 
							let offset = null; 
							let iov_base64 = prompt("libc\nread\n" +
								stats.real + "\n" + // fd
								iov.byteLength + "\n" + // length
								offset + "\n" + // position
								1 // tty
							);
							let iov_array = base64DecToArr(iov_base64);
							let rr = iov_array.length;
							let mustBreak = false;
							// Don't read more bytes than what was requested:
							if (rr > iov.byteLength) {
								rr = iov.byteLength;
								mustBreak = true;
							}
							for (var i = 0; i < rr; i++) {
								iov[r + i] = iov_array[i];
							}
							if (iov_array[iov_array.length - 1] == '\n') {
								iov[r + rr - 1] = 10;
								mustBreak = true;
							}
							r += rr;
							read += rr;
							if (mustBreak) { 
								break outer_stdin;
							}
							if ((rr == 0) && (r > 0)) {
								// We received something, and now channel is silent:
								break outer_stdin;
							}
						}
					}
				} else {
					outer: for (const iov of getiovs(iovs, iovsLen)) {
						let r = 0;
						let offset = IS_STDIN || stats.offset === undefined
							? null
							: Number(stats.offset);
						let iov_base64 = prompt("libc\nread\n" +
							stats.real + "\n" + // fd
							iov.byteLength + "\n" + // length
							offset + "\n" + // position
							0 // not tty
						);
						let iov_array = base64DecToArr(iov_base64);
						let rr = iov_array.length;
						if (!IS_STDIN) {
							stats.offset =
								(stats.offset ? stats.offset : bigint_1.BigIntPolyfill(0)) + bigint_1.BigIntPolyfill(rr);
						}
						read += rr;
						for (var i = 0; i < rr; i++) {
							iov[i] = iov_array[i];
						}
						if (rr === 0 || rr < iov.byteLength) {
							break outer;
						}
					}
			    }
                // We should not modify the offset of stdin
                this.view.setUint32(nread, read, true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_readdir: wrap((fd, bufPtr, bufLen, cookie, bufusedPtr) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READDIR);
                this.refreshMemory();
                // iOS: 
                // const entries = fs.readdirSync(stats.path, { withFileTypes: true });
                let returnString = prompt("libc\nreaddir\n" + stats.path);
                const entries = returnString.split("\n");
                if (entries.length <= 1) {
                	let errorCode = Number(returnString);
                	if (!Number.isNaN(errorCode) && (errorCode < 0)) {
						throwLibCError(-errorCode)
					}
				}
                const startPtr = bufPtr;
                for (let i = Number(cookie); i < entries.length; i += 1) {
                    // const entry = entries[i];
                    const entry = {name: entries[i]};
                    let nameLength = buffer_1.default.byteLength(entry.name);
                    if (nameLength == 0) {
                    	break;
					}
                    if (bufPtr - startPtr > bufLen) {
                        break;
                    }
                    this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(i + 1), true);
                    bufPtr += 8;
                    if (bufPtr - startPtr > bufLen) {
                        break;
                    }
                    // iOS:
                    const rstats = fs_statSync(entry.name);
                    // const rstats = fs.statSync(path.resolve(stats.path, entry.name));
                    this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.ino), true);
                    bufPtr += 8;
                    if (bufPtr - startPtr > bufLen) {
                        break;
                    }
                    this.view.setUint32(bufPtr, nameLength, true);
                    bufPtr += 4;
                    if (bufPtr - startPtr > bufLen) {
                        break;
                    }
                    let filetype;
                    // iOS: 
                    filetype = translateFileAttributesFromMode(this, fd, rstats.mode).filetype
                    // switch (true) {
                    //     case rstats.isBlockDevice():
                    //         filetype = constants_1.WASI_FILETYPE_BLOCK_DEVICE;
                    //         break;
                    //     case rstats.isCharacterDevice():
                    //         filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;
                    //         break;
                    //     case rstats.isDirectory():
                    //         filetype = constants_1.WASI_FILETYPE_DIRECTORY;
                    //         break;
                    //     case rstats.isFIFO():
                    //         filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;
                    //         break;
                    //     case rstats.isFile():
                    //         filetype = constants_1.WASI_FILETYPE_REGULAR_FILE;
                    //         break;
                    //     case rstats.isSocket():
                    //         filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;
                    //         break;
                    //     case rstats.isSymbolicLink():
                    //         filetype = constants_1.WASI_FILETYPE_SYMBOLIC_LINK;
                    //         break;
                    //     default:
                    //         filetype = constants_1.WASI_FILETYPE_UNKNOWN;
                    //         break;
                    // }
                    this.view.setUint8(bufPtr, filetype);
                    bufPtr += 1;
                    bufPtr += 3; // padding
                    if (bufPtr + nameLength >= startPtr + bufLen) {
                        // It doesn't fit in the buffer
                        break;
                    }
                    let memory_buffer = buffer_1.default.from(this.memory.buffer);
                    memory_buffer.write(entry.name, bufPtr);
					this.refreshMemory();
                    bufPtr += nameLength;
                }
                const bufused = bufPtr - startPtr;
                this.view.setUint32(bufusedPtr, Math.min(bufused, bufLen), true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_renumber: wrap((from, to) => {
                CHECK_FD(from, bigint_1.BigIntPolyfill(0));
                CHECK_FD(to, bigint_1.BigIntPolyfill(0));
                // fs.closeSync(this.FD_MAP.get(from).real);
                let returnValue = Number(prompt("libc\nclose\n" + this.FD_MAP.get(to).real));
                // if there was an error, we throw the error with the proper errno:
                if (returnValue < 0) {
                	throwLibCError(-returnValue)
				}
                this.FD_MAP.set(to, this.FD_MAP.get(from));
                this.FD_MAP.delete(from);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_seek: wrap((fd, offset, whence, newOffsetPtr) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SEEK);
                this.refreshMemory();
                switch (whence) {
                    case constants_1.WASI_WHENCE_CUR:
                        stats.offset =
                            (stats.offset ? stats.offset : bigint_1.BigIntPolyfill(0)) + bigint_1.BigIntPolyfill(offset);
                        break;
                    case constants_1.WASI_WHENCE_END:
                    	// iOS: 
                        // const { size } = fs.fstatSync(stats.real);
                        const { size } = fs_fstatSync(stats.real);
                        stats.offset = bigint_1.BigIntPolyfill(size) + bigint_1.BigIntPolyfill(offset);
                        break;
                    case constants_1.WASI_WHENCE_SET:
                        stats.offset = bigint_1.BigIntPolyfill(offset);
                        break;
                }
                this.view.setBigUint64(newOffsetPtr, stats.offset, true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_tell: wrap((fd, offsetPtr) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_TELL);
                this.refreshMemory();
                if (!stats.offset) {
                    stats.offset = bigint_1.BigIntPolyfill(0);
                }
                this.view.setBigUint64(offsetPtr, stats.offset, true);
                return constants_1.WASI_ESUCCESS;
            }),
            fd_sync: wrap((fd) => {
                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SYNC);
                // iOS: 
                // fs.fsyncSync(stats.real);
                // return constants_1.WASI_ESUCCESS;
                let returnValue = prompt("libc\nfsync\n" + stats.real);
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
            }),
            path_create_directory: wrap((fd, pathPtr, pathLen) => {
                // const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_CREATE_DIRECTORY);
                // if (!stats.path) {
                //     return constants_1.WASI_EINVAL;
                // }
                this.refreshMemory();
                const p = buffer_1.default.from(this.memory.buffer, pathPtr, pathLen).toString();
                // iOS: 
                // fs.mkdirSync(path.resolve(stats.path, p));
                let returnValue = prompt("libc\nmkdir\n" + p);
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
            }),
            path_filestat_get: wrap((fd, flags, pathPtr, pathLen, bufPtr) => {
                // const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_GET);
                // if (!stats.path) {
                //     return constants_1.WASI_EINVAL;
                // }
                this.refreshMemory();
                const p = buffer_1.default.from(this.memory.buffer, pathPtr, pathLen).toString();
                // const rstats = fs.statSync(path.resolve(stats.path, p));
                const rstats = fs_statSync(p);
                this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.dev), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.ino), true);
                bufPtr += 8;
                // this.view.setUint8(bufPtr, translateFileAttributes(this, undefined, rstats).filetype);
                this.view.setUint8(bufPtr, translateFileAttributesFromMode(this, fd, rstats.mode).filetype);
                bufPtr += 8;
                this.view.setUint32(bufPtr, Number(rstats.nlink), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.size), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), true);
                bufPtr += 8;
                this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), true);
                bufPtr += 8;
                return constants_1.WASI_ESUCCESS;
            }),
            path_filestat_set_times: wrap((fd, fstflags, pathPtr, pathLen, stAtim, stAtim_ns, stMtim, stMtim_ns, lookupflags) => {
            	// fd == AT_FDCWD <=> fd <0 --> pass it through. Otherwise, resolve it.
            	var real_fd = fd;
            	if (fd >= 0) {
					const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_SET_TIMES);
					if (!stats.path) {
						return constants_1.WASI_EINVAL;
					}
					real_fd = stats.real;
				}
                this.refreshMemory();
                // a-Shell: we can probably remove this now?
                const n = now(constants_1.WASI_CLOCK_REALTIME);
                const n_seconds = Math.trunc(n / 1000000000);
                const n_nano = n - 1000000000 * n_seconds;
                const atimNow = (lookupflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) ===
                    constants_1.WASI_FILESTAT_SET_ATIM_NOW;
                const mtimNow = (lookupflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) ===
                    constants_1.WASI_FILESTAT_SET_MTIM_NOW;
                const p = buffer_1.default.from(this.memory.buffer, pathPtr, pathLen).toString();
                // iOS: 
                // fs.utimesSync(path.resolve(stats.path, p), atimNow ? n : stAtim, mtimNow ? n : stMtim);
                // return constants_1.WASI_ESUCCESS;
                // utimensat(int fd, const char *path, const struct timespec times[2], int flag);
                let returnValue = prompt("libc\nutimensat\n" + 
					real_fd  + "\n" + 
					fstflags + "\n" + 
                	p + "\n" + 
                	Number(atimNow ? n_seconds : stAtim) + "\n" + 
                	Number(atimNow ? n_nano : stAtim_ns) + "\n" + 
                	Number(mtimNow ? n_seconds : stMtim) + "\n" + 
                	Number(mtimNow ? n_nano : stMtim_ns));
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
            }),
            path_link: wrap((oldFd, oldFlags, oldPath, oldPathLen, newFd, newPath, newPathLen) => {
                // const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_LINK_SOURCE);
                // const nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_LINK_TARGET);
                // if (!ostats.path || !nstats.path) {
                //     return constants_1.WASI_EINVAL;
                // }
                this.refreshMemory();
                const op = buffer_1.default.from(this.memory.buffer, oldPath, oldPathLen).toString();
                const np = buffer_1.default.from(this.memory.buffer, newPath, newPathLen).toString();
                // fs.linkSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np));
                // return constants_1.WASI_ESUCCESS;
                let returnValue = prompt("libc\nlink\n" + op+ "\n" + np);
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
            }),
            path_open: wrap((dirfd, dirflags, pathPtr, pathLen, oflags, fsRightsBase, fsRightsInheriting, fsFlags, fd) => {
                // const stats = CHECK_FD(dirfd, constants_1.WASI_RIGHT_PATH_OPEN);
                fsRightsBase = bigint_1.BigIntPolyfill(fsRightsBase);
                fsRightsInheriting = bigint_1.BigIntPolyfill(fsRightsInheriting);
                const read = (fsRightsBase & (constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_READDIR)) !==
                    bigint_1.BigIntPolyfill(0);
                const write = (fsRightsBase &
                    (constants_1.WASI_RIGHT_FD_DATASYNC |
                        constants_1.WASI_RIGHT_FD_WRITE |
                        constants_1.WASI_RIGHT_FD_ALLOCATE |
                        constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE)) !==
                    bigint_1.BigIntPolyfill(0);
                let noflags;
                if (write && read) {
                    noflags = fs.constants.O_RDWR;
                }
                else if (read) {
                    noflags = fs.constants.O_RDONLY;
                }
                else if (write) {
                    noflags = fs.constants.O_WRONLY;
                }
                // fsRightsBase is needed here but perhaps we should do it in neededInheriting
                let neededBase = fsRightsBase | constants_1.WASI_RIGHT_PATH_OPEN;
                let neededInheriting = fsRightsBase | fsRightsInheriting;
                if ((oflags & constants_1.WASI_O_CREAT) !== 0) {
                    noflags |= fs.constants.O_CREAT;
                    neededBase |= constants_1.WASI_RIGHT_PATH_CREATE_FILE;
                }
                if ((oflags & constants_1.WASI_O_DIRECTORY) !== 0) {
                    noflags |= fs.constants.O_DIRECTORY;
                }
                if ((oflags & constants_1.WASI_O_EXCL) !== 0) {
                    noflags |= fs.constants.O_EXCL;
                }
                if ((oflags & constants_1.WASI_O_TRUNC) !== 0) {
                    noflags |= fs.constants.O_TRUNC;
                    neededBase |= constants_1.WASI_RIGHT_PATH_FILESTAT_SET_SIZE;
                }
                // Convert file descriptor flags.
                if ((fsFlags & constants_1.WASI_FDFLAG_APPEND) !== 0) {
                    noflags |= fs.constants.O_APPEND;
                }
                if ((fsFlags & constants_1.WASI_FDFLAG_DSYNC) !== 0) {
                    if (fs.constants.O_DSYNC) {
                        noflags |= fs.constants.O_DSYNC;
                    }
                    else {
                        noflags |= fs.constants.O_SYNC;
                    }
                    neededInheriting |= constants_1.WASI_RIGHT_FD_DATASYNC;
                }
                if ((fsFlags & constants_1.WASI_FDFLAG_NONBLOCK) !== 0) {
                    noflags |= fs.constants.O_NONBLOCK;
                }
                if ((fsFlags & constants_1.WASI_FDFLAG_RSYNC) !== 0) {
                    if (fs.constants.O_RSYNC) {
                        noflags |= fs.constants.O_RSYNC;
                    }
                    else {
                        noflags |= fs.constants.O_SYNC;
                    }
                    neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;
                }
                if ((fsFlags & constants_1.WASI_FDFLAG_SYNC) !== 0) {
                    noflags |= fs.constants.O_SYNC;
                    neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;
                }
                if (write &&
                    (noflags & (fs.constants.O_APPEND | fs.constants.O_TRUNC)) === 0) {
                    neededInheriting |= constants_1.WASI_RIGHT_FD_SEEK;
                }
                this.refreshMemory();
                const p = buffer_1.default.from(this.memory.buffer, pathPtr, pathLen).toString();
                const fullUnresolved = p;
                let full = fullUnresolved
                // iOS: the call sets returnValue to errno
                const realfd = Number(prompt("libc\nopen\n" + full + "\n" + noflags));
                // if there was an error, we throw the error with the proper errno:
                if (realfd < 0) {
                	throwLibCError(-realfd)
				}
                /* iOS: comment this out:
                if (path.relative(stats.path, fullUnresolved).startsWith("..")) {
                    return constants_1.WASI_ENOTCAPABLE;
                }
                let full;
                try {
                    full = fs.realpathSync(fullUnresolved);
                    if (path.relative(stats.path, full).startsWith("..")) {
                        return constants_1.WASI_ENOTCAPABLE;
                    }
                }
                catch (e) {
                    if (e.code === "ENOENT") {
                        full = fullUnresolved;
                    }
                    else {
                        throw e;
                    }
                }
                const realfd = fs.openSync(full, noflags);
                */
                const newfd = [...this.FD_MAP.keys()].reverse()[0] + 1;
                this.FD_MAP.set(newfd, {
                    real: realfd,
                    filetype: undefined,
                    // offset: BigInt(0),
                    rights: {
                        base: neededBase,
                        inheriting: neededInheriting
                    },
                    path: full
                });
                stat(this, newfd);
                this.view.setUint32(fd, newfd, true);
                return constants_1.WASI_ESUCCESS;
            }),
            path_readlink: wrap((fd, pathPtr, pathLen, buf, bufLen, bufused) => {
                // const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_READLINK);
                // if (!stats.path) {
                //     return constants_1.WASI_EINVAL;
                // }
                this.refreshMemory();
                const p = buffer_1.default.from(this.memory.buffer, pathPtr, pathLen).toString();
                const full = p;
                // iOS: 
                // const r = fs.readlinkSync(full);
                const r = prompt("libc\nreadlink\n" + full);
                // if r is "\n-2' it is most likely an error code
                if (r.startsWith('\n')) {
                	let errorCode = Number(r.substr(1));
                	if (!Number.isNaN(errorCode) && (errorCode < 0)) {
						throwLibCError(-errorCode)
					}
				}
                const used = buffer_1.default.from(this.memory.buffer).write(r, buf, bufLen);
                this.refreshMemory();
                this.view.setUint32(bufused, used, true);
                return constants_1.WASI_ESUCCESS;
            }),
            path_remove_directory: wrap((fd, pathPtr, pathLen) => {
                // const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_REMOVE_DIRECTORY);
                // if (!stats.path) {
                //     return constants_1.WASI_EINVAL;
                // }
                this.refreshMemory();
                const p = buffer_1.default.from(this.memory.buffer, pathPtr, pathLen).toString();
                // iOS: 
                // fs.rmdirSync(path.resolve(stats.path, p));
                let returnValue = prompt("libc\nrmdir\n" + p);
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
            }),
            path_rename: wrap((oldFd, oldPath, oldPathLen, newFd, newPath, newPathLen) => {
                // const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_RENAME_SOURCE);
                // const nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_RENAME_TARGET);
                // if (!ostats.path || !nstats.path) {
                //     return constants_1.WASI_EINVAL;
                // }
                this.refreshMemory();
                const op = buffer_1.default.from(this.memory.buffer, oldPath, oldPathLen).toString();
                const np = buffer_1.default.from(this.memory.buffer, newPath, newPathLen).toString();
                // iOS:
                // fs.renameSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np));
                // return constants_1.WASI_ESUCCESS;
                let returnValue = prompt("libc\nrename\n" + op+"\n" + np);
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
            }),
            path_symlink: wrap((oldPath, oldPathLen, fd, newPath, newPathLen) => {
                // const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_SYMLINK);
                // if (!stats.path) {
                //     return constants_1.WASI_EINVAL;
                // }
                this.refreshMemory();
                const op = buffer_1.default.from(this.memory.buffer, oldPath, oldPathLen).toString();
                const np = buffer_1.default.from(this.memory.buffer, newPath, newPathLen).toString();
                // fs.symlinkSync(op, path.resolve(stats.path, np));
                // return constants_1.WASI_ESUCCESS;
                let returnValue = prompt("libc\nsymlink\n" + op+ "\n" + np);
                if (returnValue === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
            }),
            path_unlink_file: wrap((fd, pathPtr, pathLen) => {
                // const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_UNLINK_FILE);
                // if (!stats.path) {
                //     return constants_1.WASI_EINVAL;
                // }
                this.refreshMemory();
                const p = buffer_1.default.from(this.memory.buffer, pathPtr, pathLen).toString();
                // iOS:
                // fs.unlinkSync(path.resolve(stats.path, p));
                // return constants_1.WASI_ESUCCESS;
                const r = prompt("libc\nunlink\n" + p);
                if (r === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(r));
				}
            }),
            poll_oneoff: (sin, sout, nsubscriptions, nevents) => {
                let eventc = 0;
                let waitEnd = 0;
                this.refreshMemory();
                for (let i = 0; i < nsubscriptions; i += 1) {
                    const userdata = this.view.getBigUint64(sin, true);
                    sin += 8;
                    const type = this.view.getUint8(sin);
                    sin += 1;
                    switch (type) {
                        case constants_1.WASI_EVENTTYPE_CLOCK: {
                            sin += 7; // padding
                            const identifier = this.view.getBigUint64(sin, true);
                            sin += 8;
                            const clockid = this.view.getUint32(sin, true);
                            sin += 4;
                            sin += 4; // padding
                            const timestamp = this.view.getBigUint64(sin, true);
                            sin += 8;
                            const precision = this.view.getBigUint64(sin, true);
                            sin += 8;
                            const subclockflags = this.view.getUint16(sin, true);
                            sin += 2;
                            sin += 6; // padding
                            const absolute = subclockflags === 1;
                            let e = constants_1.WASI_ESUCCESS;
                            const n = bigint_1.BigIntPolyfill(now(clockid));
                            if (n === null) {
                                e = constants_1.WASI_EINVAL;
                            }
                            else {
                                const end = absolute ? timestamp : n + timestamp;
                                waitEnd =
                                    end > waitEnd ? end : waitEnd;
                            }
                            this.view.setBigUint64(sout, userdata, true);
                            sout += 8;
                            this.view.setUint16(sout, e, true); // error
                            sout += 2; // pad offset 2
                            this.view.setUint8(sout, constants_1.WASI_EVENTTYPE_CLOCK);
                            sout += 1; // pad offset 3
                            sout += 5; // padding to 8
                            eventc += 1;
                            break;
                        }
                        case constants_1.WASI_EVENTTYPE_FD_READ:
                        case constants_1.WASI_EVENTTYPE_FD_WRITE: {
                            sin += 3; // padding
                            const fd = this.view.getUint32(sin, true);
                            sin += 4;
                            this.view.setBigUint64(sout, userdata, true);
                            sout += 8;
                            this.view.setUint16(sout, constants_1.WASI_ENOSYS, true); // error
                            sout += 2; // pad offset 2
                            this.view.setUint8(sout, type);
                            sout += 1; // pad offset 3
                            sout += 5; // padding to 8
                            eventc += 1;
                            break;
                        }
                        default:
                            return constants_1.WASI_EINVAL;
                    }
                }
                this.view.setUint32(nevents, eventc, true);
                while (bindings.hrtime() < waitEnd) {
                    // nothing
                }
                return constants_1.WASI_ESUCCESS;
            },
            // iOS/ashell additions:
            //  Do NOT remove ashell_getenv, ashell_setenv, ashell_unsetenv as old binaries 
            //  are referencing them.
            ashell_getenv: wrap((variablePtr, variableLen, buf, bufLen, bufused) => {
                 this.refreshMemory();
                 const v = buffer_1.default.from(this.memory.buffer, variablePtr, variableLen).toString();
                 const r = prompt("libc\ngetenv\n" + v);
                 if (r === "0") {
 					this.view.setUint32(bufused, 0, true);
 				} else {
 					const used = buffer_1.default.from(this.memory.buffer).write(r, buf, bufLen);
 					this.view.setUint32(bufused, used, true);
 				}
                 this.refreshMemory();
                 return constants_1.WASI_ESUCCESS;
             }),
             ashell_setenv: wrap((variablePtr, variableLen, valuePtr, valueLen, force) => {
                 this.refreshMemory();
                 const v = buffer_1.default.from(this.memory.buffer, variablePtr, variableLen).toString();
                 const val = buffer_1.default.from(this.memory.buffer, valuePtr, valueLen).toString();
                 const returnValue = prompt("libc\nsetenv\n" + v + "\n" + val + "\n" + force);
                 if (returnValue === "0") {
 					return constants_1.WASI_ESUCCESS;
 				} else {
                 	throwLibCError(-Number(returnValue));
 				}
                 return constants_1.WASI_ESUCCESS;
             }),
             ashell_unsetenv: wrap((variablePtr, variableLen) => {
                 this.refreshMemory();
                 const v = buffer_1.default.from(this.memory.buffer, variablePtr, variableLen).toString();
                 const r = prompt("libc\nunsetenv\n" + v);
                 if (r === "0") {
 					return constants_1.WASI_ESUCCESS;
 				} else {
                 	throwLibCError(-Number(r));
 				}
                 return constants_1.WASI_ESUCCESS;
             }),
            ashell_getcwd: wrap((buf, bufLen, bufused) => {
                const r = prompt("libc\ngetcwd"); // getcwd cannot throw
                const used = buffer_1.default.from(this.memory.buffer).write(r, buf, bufLen);
                this.refreshMemory();
                this.view.setUint32(bufused, used, true);
                return constants_1.WASI_ESUCCESS;
            }),
            ashell_chdir: wrap((path, pathLen) => {
                this.refreshMemory();
                const p = buffer_1.default.from(this.memory.buffer, path, pathLen).toString();
                const r = prompt("libc\nchdir\n" + p); 
                if (r === "true") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(1); // permission error
				}
                return constants_1.WASI_ESUCCESS;
            }),
            ashell_fchdir: wrap((fd) => {
                const r = prompt("libc\nfchdir\n" + fd); 
                if (r === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(-Number(returnValue));
				}
                return constants_1.WASI_ESUCCESS;
            }),
            ashell_system: wrap((command, commandLen) => {
                this.refreshMemory();
                const p = buffer_1.default.from(this.memory.buffer, command, commandLen).toString();
                const r = prompt("libc\nsystem\n" + p); 
                if (r === "0") {
					return constants_1.WASI_ESUCCESS;
				} else {
                	throwLibCError(Number(returnValue));
				}
                return constants_1.WASI_ESUCCESS;
            }),
            proc_exit: (rval) => {
                bindings.exit(rval);
                return constants_1.WASI_ESUCCESS;
            },
            proc_raise: (sig) => {
                if (!(sig in constants_1.SIGNAL_MAP)) {
                    return constants_1.WASI_EINVAL;
                }
                bindings.kill(constants_1.SIGNAL_MAP[sig]);
                return constants_1.WASI_ESUCCESS;
            },
            random_get: (bufPtr, bufLen) => {
                this.refreshMemory();
                bindings.randomFillSync(new Uint8Array(this.memory.buffer), bufPtr, bufLen);
                return constants_1.WASI_ESUCCESS;
            },
            sched_yield() {
                // Single threaded environment
                // This is a no-op in JS
                return constants_1.WASI_ESUCCESS;
            },
            sock_recv() {
                return constants_1.WASI_ENOSYS;
            },
            sock_send() {
                return constants_1.WASI_ENOSYS;
            },
            sock_shutdown() {
                return constants_1.WASI_ENOSYS;
            }
        };
        // Wrap each of the imports to show the calls in the console
        // Object.keys(this.wasiImport).forEach((key: string) => {
        //   const prevImport = this.wasiImport[key];
        //   this.wasiImport[key] = function(...args: any[]) {
        //     console.log(`WASI: wasiImport called: ${key} (${args})`);
        //     try {
        //       let result = prevImport(...args);
        //       console.log(`WASI:  => ${result}`);
        //       return result;
        //     } catch (e) {
        //       console.log(`Catched error: ${e}`);
        //       throw e;
        //     }
        //   };
        // });
    }
    refreshMemory() {
        // @ts-ignore
        if (!this.view || this.view.buffer.byteLength === 0) {
            this.view = new dataview_1.DataViewPolyfill(this.memory.buffer);
        }
    }
    setMemory(memory) {
        this.memory = memory;
    }
    start(instance) {
        const exports = instance.exports;
        if (exports === null || typeof exports !== "object") {
            throw new Error(`instance.exports must be an Object. Received ${exports}.`);
        }
        const { memory } = exports;
        if (!(memory instanceof WebAssembly.Memory)) {
            throw new Error(`instance.exports.memory must be a WebAssembly.Memory. Recceived ${memory}.`);
        }
        this.setMemory(memory);
        if (exports._start) {
            exports._start();
        }
    }
    getImportNamespace(module) {
        let namespace = null;
        for (let imp of WebAssembly.Module.imports(module)) {
            // We only check for the functions
            if (imp.kind !== "function") {
                continue;
            }
            // console.log("function: " + imp.name);
            // We allow functions in other namespaces other than wasi
            if (!imp.module.startsWith("wasi_")) {
                continue;
            }
            if (!namespace) {
                namespace = imp.module;
            }
            else {
                if (namespace !== imp.module) {
                    throw new Error("Multiple namespaces detected.");
                }
            }
        }
        return namespace;
    }
    getImports(module) {
        let namespace = this.getImportNamespace(module);
        switch (namespace) {
            case "wasi_unstable":
                return {
                    wasi_unstable: this.wasiImport
                };
            case "wasi_snapshot_preview1":
                return {
                    wasi_snapshot_preview1: this.wasiImport
                };
            default:
                throw new Error("Can't detect a WASI namespace for the WebAssembly Module");
        }
    }
}
exports.default = WASIDefault;
WASIDefault.defaultBindings = defaultBindings;
// Also export it as a field in the export object
exports.WASI = WASIDefault;
